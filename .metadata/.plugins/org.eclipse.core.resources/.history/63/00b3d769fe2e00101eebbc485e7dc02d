package com.app.util;

import com.app.entity.User;
import com.app.pojo.ClientData;
import com.app.repository.UserRepository;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.itextpdf.forms.PdfAcroForm;
import com.itextpdf.forms.fields.PdfFormField;
import com.itextpdf.kernel.pdf.*;

import java.io.File;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.springframework.beans.factory.annotation.Autowired;

public class FillAcroForm {


    // Dummy data generator based on field names
	private static String generateDummyData(String fieldName, String clientData1Json) {
	    try {
	        ObjectMapper objectMapper = new ObjectMapper();
	        ClientData clientData = objectMapper.readValue(clientData1Json, ClientData.class);
	   
	        fieldName = fieldName.toLowerCase();
	        if (fieldName.contains("certificatedate")) return "";
	        if (fieldName.contains("replacement[0].surname[0]")) return clientData.getBasicInformation().getFormsdata().getLastName();
	        if (fieldName.contains("replacement[0].givenname[0]"))
	            return clientData.getBasicInformation().getFormsdata().getFirstName() != null
	                ? clientData.getBasicInformation().getFormsdata().getFirstName()
	                : "";
	        if (fieldName.contains("bcsurname[0]")) return clientData.getBasicInformation().getFormsdata().getLastName();
	        if (fieldName.contains("bcgivenname[0]")) return clientData.getBasicInformation().getFormsdata().getFirstName();
	        if (fieldName.contains("dob[0]")) return formatIsoDate(clientData.getBasicInformation().getFormsdata().getDob());
	        if (fieldName.contains("pob")) return "";
	        if (fieldName.contains("country")) return clientData.getBasicInformation().getFormsdata().getCitizenship().get(0);
	        if (fieldName.contains("feet")) return "";
	        if (fieldName.contains("clientuci")) return "";
	        if (fieldName.contains("inches")) return "";
	        if (fieldName.contains("birthcountry")) return "";
	      
	        
	        
	        
	        //parent 1
	        if (fieldName.contains("parent1[0].information[0].surname[0]")) return clientData.getParentDetails().getFormsdata().getFatherInfo().getFirstName();
	        if (fieldName.contains("parent1[0].information[0].givenname[0]")) return clientData.getParentDetails().getFormsdata().getFatherInfo().getLastName();
	        if (fieldName.contains("parent1[0].information[0].othernames[0]")) return "";
	        if (fieldName.contains("parent1[0].information[0].birthcountry[0]")) return clientData.getParentDetails().getFormsdata().getFatherInfo().getBirthCountry();
	        if (fieldName.contains("parent1[0].information[0].certificatenumber[0]")) return "";
	        if (fieldName.contains("parent1[0].information[0].marriagedate[0]")) return "";
	        if (fieldName.contains("parent1[0].information[0].placeofmarriage[0]")) return "";
	        if (fieldName.contains("parent1[0].information[0].birthdate[0]")) return formatIsoDate(clientData.getParentDetails().getFormsdata().getFatherInfo().getDob());
	        
	        //parent 1
	        if (fieldName.contains("parent2[0].information[0].surname[0]")) return clientData.getParentDetails().getFormsdata().getMotherInfo().getFirstName();
	        if (fieldName.contains("parent2[0].information[0].givenname[0]")) return clientData.getParentDetails().getFormsdata().getMotherInfo().getLastName();
	        if (fieldName.contains("parent2[0].information[0].othernames[0]")) return "";
	        if (fieldName.contains("parent2[0].information[0].birthcountry[0]")) return clientData.getParentDetails().getFormsdata().getMotherInfo().getBirthCountry();
	        if (fieldName.contains("parent2[0].information[0].certificatenumber[0]")) return "";
	        if (fieldName.contains("parent2[0].information[0].marriagedate[0]")) return "";
	        if (fieldName.contains("parent2[0].information[0].placeofmarriage[0]")) return "";
	        if (fieldName.contains("parent2[0].information[0].birthdate[0]")) return formatIsoDate(clientData.getParentDetails().getFormsdata().getMotherInfo().getDob());
	        
	        
	        
	   

	    } catch (Exception e) {
	        e.printStackTrace(); // You can log this instead
	    }

	    return "";
	}

	
	 public static String formatIsoDate(String isoDate) {
	        if (isoDate == null || isoDate.isEmpty()) return "";
	        try {
	            OffsetDateTime dateTime = OffsetDateTime.parse(isoDate);
	            return dateTime.format(DateTimeFormatter.ofPattern("yyyy-MM-dd"));
	        } catch (Exception e) {
	            return isoDate; // return as-is if parsing fails
	        }
	    }

 
    
    public static void fillPdfWithDummyData(String inputPath, String outputPath, String jsonData) {
        try (PdfReader reader = new PdfReader(inputPath);
             PdfWriter writer = new PdfWriter(outputPath);
             PdfDocument pdfDoc = new PdfDocument(reader, writer)) {
            ObjectMapper objectMapper = new ObjectMapper();

            // ‚úÖ Corrected mapping: Use a TypeReference for generic types like Map<String, Object>
            Map<String, Object> dataMap = objectMapper.readValue(jsonData, new TypeReference<Map<String, Object>>() {});

            // ‚úÖ Extract maps from nested structure
            Map<String, Object> basicInfo = extractMap(dataMap, "basicInformation", "formsdata");
            Map<String, Object> parentFormsData = extractMap(dataMap, "parentDetails", "formsdata");
            List<Map<String, Object>> addressList = extractList(dataMap, "addressHistory", "formsdata");

            // ‚úÖ Extract nested parent info maps
            Map<String, Object> motherInfo = (Map<String, Object>) parentFormsData.get("motherInfo");
            Map<String, Object> fatherInfo = (Map<String, Object>) parentFormsData.get("fatherInfo");

            // ‚úÖ Print or use the data
            System.out.println("üßç Basic Information:");
            basicInfo.forEach((k, v) -> System.out.println(" - " + k + ": " + v));

            System.out.println("\nüë© Mother Info:");
            motherInfo.forEach((k, v) -> System.out.println(" - " + k + ": " + v));

            System.out.println("\nüë® Father Info:");
            fatherInfo.forEach((k, v) -> System.out.println(" - " + k + ": " + v));

            System.out.println("\nüè† Address History:");
            for (Map<String, Object> address : addressList) {
                System.out.println(" - City: " + address.get("city") + ", From: " + address.get("from") + ", To: " + address.get("to"));
            }
             
            PdfAcroForm form = PdfAcroForm.getAcroForm(pdfDoc, true);
            if (form == null || form.getFormFields().isEmpty()) {
                System.out.println("‚ùå No AcroForm fields found.");
                return;
            }

            Map<String, PdfFormField> fields = form.getFormFields();
            for (String fieldName : fields.keySet()) {
                System.out.println(fieldName);  // Print the field name
            }

            for (Map.Entry<String, PdfFormField> entry : fields.entrySet()) {
                String fullFieldName = entry.getKey();
                PdfFormField field = entry.getValue();
                String dummyValue = generateDummyData(fullFieldName,jsonData);
                field.setValue(dummyValue);
            }

            // Optionally flatten fields
            // form.flattenFields();

            System.out.println("‚úÖ PDF saved to: " + outputPath);

        } catch (IOException e) {
            System.err.println("‚ùå Error filling PDF: " + e.getMessage());
        }
    }
    
    private static Map<String, Object> extractMap(Map<String, Object> root, String level1, String level2) {
        if (root.containsKey(level1)) {
            Object level1Obj = root.get(level1);
            if (level1Obj instanceof Map) {
                Map<String, Object> level1Map = (Map<String, Object>) level1Obj;
                if (level1Map.containsKey(level2)) {
                    return (Map<String, Object>) level1Map.get(level2);
                }
            }
        }
        return Collections.emptyMap();
    }

    private static List<Map<String, Object>> extractList(Map<String, Object> root, String level1, String level2) {
        if (root.containsKey(level1)) {
            Object level1Obj = root.get(level1);
            if (level1Obj instanceof Map) {
                Map<String, Object> level1Map = (Map<String, Object>) level1Obj;
                if (level1Map.containsKey(level2)) {
                    return (List<Map<String, Object>>) level1Map.get(level2);
                }
            }
        }
        return Collections.emptyList();
    }

}
